# Ohj.turv - Luentopäiväkirja
Tehnyt R.Immonen 

## Luento 1
Ensimmäisellä videoluennolla käydään läpi MIT:n tietojärjestelmien tietoturvallisuus kurssin aiheita yleisesti, sekä tietoturvallisuuden merkitystä, miksi se on yleisesti ottaen niin hankalaa, ja mitä se vaatii, että pystytään ohjelmoimaan tietoturvallisesti ja osataan näin toteutettua tietoturvallinen ohjelmisto. Tietoturva on yleisesti johonkin maaliin pyrkimistä, kun hyökkääjä vaanii kulman takana. Tämä on totta, maaliin ei päästä, jos reitillä kaadutaan johonkin hyökkääjän tekemään ansaan. Tietoturvamallin ensimmäinen osa on tietoturvapolitiikka: luottamuksellisuus, eheys ja saatavuus, kaikki nämä kohdat ovat toteuduttava, vaikka uhkia on joka puolella.  Tietoturvamallin toinen osa on uhkakuvat, olettamuksista mitä hyökkää pystyy ehkä tekemään. Hyökkääjät yllättävät usein ja myös he kehittyvät ja opiskelevat uusia tekniikoita. Tämä on tärkeä kohta, että osataan varautua oikeisiin uhkiin, eikä myöskään yli varauduta, koska se on kallista.  Tietoturvamallin kolmas osa ovat mekanismit: ohjelmistot, komponentit ja systeemit. Näillä mekanismeilla pyritään toteuttamaan voimassaolevaa tietoturvapolitiikkaa, niin kauan, kun hyökkääjä kykenee tekemään vain uhkakuvissa oletettuja hyökkäyksiä.  
Tietoturvapolitiikka voidaan tuhota helposti, se voidaan tuhota samalla tavalla, kun ensimmäisellä MIT:n videoluennolla läpikäydyssä esimerkissä.  Siinä kolmen eri verkkosivuston erilainen tietoturvapolitiikka ja toimintatavat aiheuttivat yhdessä tietoturva-aukon yhdelle verkkosivustolle. Esimerkki oli erittäin mielenkiintoinen ja tuokin selvästi esille tarpeen luoda yhtenäisiä käytäntöjä verkkosivustoille sisäänkirjautumisiin ja salasanojen vaihtoon. Itselläni oli vasta samanlainen kokemus PayPal-sivuston salasanan uusimisen ja kyseisen verkkosivun varmennustapojen kanssa. Ensimmäinen ja toinen varmennustapa, eivät toimineet kohdallani, koska puhelinnumeroni oli muuttunut ja en pystynyt vastaamaan puheluun tai tekstiviestiin. Kolmas varmennustapa oli turvakysymykset, joita en ollut ilmeisesti kirjoittanut ylös. Viimeinen varmennustapa oli tietää luottokortin koko numero kahden viimeisen numeron perusteella, joka ei tietenkään myöskään toiminut kohdallani, koska luottokortti oli välillä uusittu. Tällä tavalla kaikki varmennustavat pettivät kohdallani. Siitä tulikin mieleen, että voisikohan tulevaisuudessa käyttää pankkitunnuksia, kuvallista henkilökorttia tai jotain perinteisempiä tapoja hyväksi varmennuksessa ja pitäisikö tähän tarkoitukseen olla omia yrityksiä, jotka tarjoaisivat standardisoitua varmennuspalvelua muille verkkokaupoille. Muutoin on varmaan vaikeaa saada näitä varmennustapoja yhdenmukaistettua. Uhkakuvatkin voidaan arvioida väärin, koska ihminen on arvaamaton ja tekee asioita, joita on vaikea ennustaa. Toinen asia, joka on vaikea ennakoida, on tekniikan kehitys. Esimerkiksi nykytekniikan avulla voidaan murtaa vanhat salasanat jo hyvinkin tehokkaasti. Olettamusten on siis hyvä seurata aikaa ja teknologian evoluutiota. Tietoturvamallin osista mekanismit ovat helpoimpia todeta, joka toimiviksi tai sitten toimimattomiksi. Toimimattomista mekanismeista on hyvä esimerkki videoluennolla toiminut esimerkki Applen iCloud:sta, jossa koodaaja oli unohtanut laittaa salasanan kyselyyn aikarajoituksen, miten usein väärin syötettyä salasanaa voi vaihtaa ja kokeilla uudelleen. Nykytekniikan avulla onkin hyvin mahdollista, että kokeilemalla lukuisilla eri salasanoilla voi päästä murtautumaan sisälle web-sivustolle jo yhden päivän aikana. Tämä johtuu siitä, että ihmiset valitsevat usein ennustettavia eli huonoja salasanoja. Toinen hyvä esimerkki oli C-kielen merkkijonon lopetusmerkin hyväksi käyttäminen SSL-sertifikaatin väärentämisessä ja käyttöön saamisessa. Siinä merkkijonon lopetusmerkin \0 avulla saatiin siirretty SSL-sertifikaatti kaapatulle sivulle oman sivun sertifikaatin avulla. Jälleen hyvä esimerkki ihmisen kekseliäisyydestä ja ennalta arvaamattomuudesta. Luentovideolla esitetään myös kysymys, että onko SSL-sertifikaatteja myöntävät yritykset CA:t (eng. Certificate Authority) kaikki niin turvallisia, että niihin voi luottaa. Kuka takaa, että sadat CA:t ovat suojanneet yhteytensä ja järjestelmänsä niin, että niistä yhdestäkään ei löydy mitään moitittavaa. Varmaan ihan aiheellinen kysymys tämäkin. Luennosta jäi mielikuva, että mitä tahansa voi tapahtua ja kehenkään ei voi luottaa, koska jos perinteiset hakkerit nukkuvat, niin ainakin NSA valvoo, tarkkailee ja tunkeutuu koteihimme tietokoneiden kautta.  

## Luento 2
Toisen videoluennon aihe on ”kuinka hallitset kaappaushyökkäyksiä”. Aluksi videoluennolla käydään läpi ylivuotoja yleisesti, niiden ehkäiseminen on vielä tänäkin päivänä yhtenä päähaasteena tietoturvan parantamisessa. Mahdollisuus ylivuodoille on vieläkin olemassa, vaikka niiden ehkäisyyn on kehitetty monia eri menetelmiä ja että näitä menetelmiä voidaan käyttää myös ristiin toistensa kanssa. Pääsyynä ylivuotojen olemassaololle on C:n ja C++:n kaltaiset matalantason ohjelmointikielet, joita on käytetty ja tullaan käyttämään vielä pitkään eri laitteissa ja sovelluksissa. Nämä kielet ovat käytössä etenkin sulautetuissa järjestelmissä, tietoliikenne komponenteissa ja tulevaisuuden IoT-laitteissa, joiden määrä tuleekin lisääntymään räjähdysmäisesti. IoT-laitteet tulevat olemaan myös tietoturvan näkökulmasta riskialttiita, koska ne liittyvät koneisiin, joiden kaappaus voi aiheuttaa vakavia ongelmia myös henkilöiden, rakennusten ja esineiden fyysiselle turvallisuudelle. Ongelman C-kielen kohdalla aiheuttaa erityisesti sen muistinkäsittely ominaisuudet, jotka sallivat ohjelmoijille monia eri vapauksia kirjoittaa ja hallita muistipaikkoja sekä pino- ja kekorakenteita. Hyökkääjä voi esimerkiksi yrittää saada pino-osoittimet haltuunsa ylikirjoittamalla muistipaikat jollain keksityllä paluuosoitteella. Tämän jälkeen aliohjelman käsittely siirtyy jonnekin hyökkääjän tahtomaan muistipaikkaan ja sitten alkaa tapahtua ei-toivottuja asioita, kuten tiedostojen siirtoa, oikeuksien hallinnan riistoa tai mitä tahansa hyökkääjä keksiikin. Hyökkääjä voi tyytyä myös vain kaatamaan ohjelman. Ylivuoto ongelmalle on tosin keksitty myös monta eri korjaustapaa ja ne voidaan jakaa kolmeen eri päätapaan, jotka ovat: virheiden välttäminen C-kieltä koodattaessa, koodausvirheiden löytäminen työkalujen avulla ja viimeisenä on käyttää turvallisia kieliä, kuten Javaa, Pythonia tai C#:a. Koko ohjelmointikielen vaihtaminen ei ole yleensä taloudellisesti järkevää ja sen takia joudutaan tyytymään usein kahteen ensimmäiseen korjaustapaan. Yksi työkalu ylivuotojen estämiseen, joka toisella videoluennolla esitetään, on kanarialinnun (eng. canary) käyttäminen ylivuotojen torjunnassa. Kanarialintu voi olla esimerkiksi jokin luku, jota tarkistetaan jostain pinon muistipaikasta. Sitten kun ollaan lopettamassa pinossa jokin aliohjelma ja ollaan palaamassa return-käskyllä muistiosoitteen osoittamaan seuraavaan kohtaan ohjelmassa, niin tarkastetaan ”kanarialintu” ensin, jos tämä luku on ylikirjoitettu jollain toisella merkkijonolla, niin tiedetään, että ohjelma on saastunut, eikä jatketa sen suorittamista. Nykyään myös C-kääntäjissä voi olla automaattinen kanarialinnun lisäysmahdollisuus, jolloin itse koodia ei tarvitse muuttaa miksikään, laittaa vaan toiminnon päälle. Menetelmän nimi tulee kaivoksissa käytetyistä kanarialinnuista, jotka valvoivat niissä ennen kaasuvuotoja. Menetelmä kuulostavat toimivalta ratkaisuilta myös pieniin ja langattomiin järjestelmiin, IoT-laitteisiin ja sensoriverkkoihin, koska ne eivät varaa niin paljon muistia ja kuluta siten tarpeettomasti energiaa. Toinen tapa ylivuotojen estämiseen on käyttää rajojen tarkastusta, missä puskurin ja tallennettavan tiedon kokoa valvotaan ja kirjoitus estetään, jos koko ei täsmää. If-lauseiden lisääminen voi kuitenkin tehdä koodista hitaan ja C-kielen käyttäminen ei ole enää niin perusteltua. Yksi tapa rajojen tarkastukseen on käyttää sähköaita-menetelmään, jossa jokaisen allokoidun muistiosoitteen viereen lisätään turvasivu, joka hälyttää, jos siihen kajotaan. Menetelmä aiheuttaa ohjelman välittömän kaatumisen, eikä muistiosoitteen korruptoidu pikkuhiljaa, niin kuin toisissa menetelmissä. Toimenpide kuluttaa valtavasti muistia, mutta on tehokas, siksi kokonaisen muistisivun lisääminen ei yleensä tule kysymykseen ja menetelmä on melko harvinainen. Toinen tapa rajojen tarkastukseen on käyttää ”lihavia osoittimia”. Menetelmässä osoittimeen lisätään raja-arvot. Nyt osoitin koostuu muistiosoitteen lisäksi muistiosoitteessa asuvan olion raja-arvoista. Tässä menetelmässä kääntäjä täytyy muokata käyttämään lihavia osoittimia ja kääntää ohjelmat uudelleen. Kääntäjä muodostaa koodin, joka keskeyttää ohjelman, jos osoitin on rajojen ulkopuolella. Lihavien osoittimien käyttö voi olla kallista, koska kaikki osoittimet on käytävä läpi. Toinen ongelma on se, että lihavat osoittimet eivät ole yhteensopivia kaikkien ohjelmien kanssa. 
## Luento 3
Kolmannen videoluennon aihe on ”Puskurin ylivuoto hyökkäysten arviointi”, joka jatkaa edellisellä luennolla aloitettua aihetta: rajojen tarkastus tavoista.  Kolmas tapa rajojen tarkastukseen on käyttää BBC-menetelmää (eng. Baggy Bounds Check). Menetelmän perusidea on tallentaa jokaisesta allokoidun objektin koko. Tämä voidaan tehdä esimerkiksi tallentamalla arvo, joka saadaan malloc()-funktiolla: ( char*p = malloc(mem_size);). Staattisille muuttujille arvot määrittelee kääntäjä -> (char p[256];). Jokaisesta osoittimelle tehdään kaksi operaatiota: otetaan talteen osoittimen aritmeettinen arvo -> (char *p = p + 256;). Haetaan ja otetaan talteen arvo, johon osoitin osoittaa-> (char ch = *q;).  Mihin aritmeettista arvoa sitten tarvitaan, eikö osoittimen tähtiarvo sitten riitä yksin? Aritmeettista arvoa tarvitaan, koska sen avulla voidaan seurata osoittimien alkuperää ja määritellä siten mitkä arvot ovat sallituissa rajoissa. Mutta mihin tähtiarvoa sitten tarvitaan, eikö osoittimen aritmeettinen arvo sitten riitä yksin? Joskus invalidi osoitin osoittaa yhden hypyn päähän jonosta, eikä se ole ohjelman kannalta virhe, koska sitä voidaan käyttää silmukan lopetuksessa hyväksi. Tämä menetelmä kuulostaa ihan toimivalta, eikä kuluta muistia niin paljon kuin toiset rajojen tarkastus menetelmät. Edellisessä luennossa esitettyjen kahden tavan lisäksi, kolmas tapa ylivuotojen estämiseen on estää koodin suorittaminen pinosta. Tämän mahdollistaa muistin suoritussuojaus (lyh. NX), jonka jälkeen hyökkääjä ei voi ajaa koodia pinosta. Muistien suoritussuojaus on uudempi ominaisuus, kuin luku- ja kirjoitussuojaus, joita on voitu tehdä jo pidempää. Jotkut järjestelmät jopa vaativat, että muisti on joko kirjoitettavaa tai suoritettavaa, mutta ei molempia. Menetelmän etuja on se, että se ei vaadi sovellukseen muutoksia. Toinen hyvä puoli on se, että rauta valvoo asiaa koko ajan toisin kuin käyttöjärjestelmä.  Neljäs tapa ylivuotojen estämiseen on käyttää osoiteavaruuden satunnaistamista (ASLR), tällöin pino aloitetaan satunnaisesta paikasta.  Osoiteavaruuden satunnaistamisessa pino siirretään satunnaiseen paikkaan, jolloin hyökkääjän on vaikeampi määritellä nykyisen kehyksen paluuosoitteen sijainti ja siten määrätä puskurin sijainti shell-koodissa. Hyökkääjä voi myös käyttää gdb:tä ja selvittää, missä muistiosoitteissa kiinnostavat kohteet sijaitsevat, mutta monta kertaa hyökkäyksissä käytetään kovakoodattuja muistiosoitteita shell-koodissa, joten osoiteavaruuden satunnaistaminen vaikeuttaa usein hyökkääjän työtä arvata kelvolliset kohteet.  Onkin hyvä satunnaistaa koko osoiteavaruus: pino, keko ja DLL-tiedostojen sijainti, koska koodi on usein uudelleen sijoitettavissa ja dynaaminen lataaja voi valita satunnaisen paikan jokaiselle kirjastolle. Silti hyökkääjä voi joskus arvata tai selvittää satunnaisuuden, etenkin 32-bitin järjestelmissä, joissa 232 virtuaalinen muistiavaruus on jaettu 4 kilotavun (212) sivuihin, joten 12 bittiä ei voi satunnaistaa ylittämättä sivun rajoja. Hyökkääjä voi käyttää myös puskurin ylivuotoa ja yrittää korvata palautusosoitteen usleep(16) käskyllä, ja sen jälkeen odottaa 16 sekuntia ja seurata kaatuuko järjestelmä. Jos järjestelmä kaatuu, niin serveri luo uuden prosessin samalla ASLR-offsetillä, jonka jälkeen hyökkääjä voi vaihtaa taas omia parametrejaan. Osoiteavaruuden satunnaistaminen onkin tämän vuoksi käytännöllisempää 64-bittisissä järjestelmissä, joissa voidaan käyttää suurempia satunnaislukuja. Puskurin ylivuotojen suojaamiseen käytetään yleisesti kanarialintua (Canary), jota käytetään GNU Compiler Collectionissa ja Microsoft Visual Studiossa oletuksena. Linuxissa ja Windowsissa käytetään taas oletuksena   osoiteavaruuden satunnaistamisessa (ASLR) ja muistin suoritussuojausta (NX). Rajojen tarkastukset eivät ole yhtä yleisiä, koska järjestelmien suorituskyky laskee yleensä, kun koodin määrä lisääntyy. Toinen syy on se, että ohjelmat joudutaan uudelleen ohjelmoimaan tarkoitusta varten. Kolmas syy on väärät hälytykset. Usein on parempi hyväksyä pikku puutteet ja ei yhtään väärää hälytystä, kuin toisin päin. Tämä on totta, koska mitä tietoturvatuotteiden: palomuurien ja virustentorjuntaohjelmien kanssa yleensä käy? Ne laskevat tietokoneen suorituskykyä usein liian alas ja sitten ne poistetaan käytöstä kokonaan. Tätä tapahtuu etenkin vanhoissa tietokoneissa, kun niihin ladataan uudet tietoturvaohjelmat.   

## Luento 4
Neljännellä videoluennon teemana oli eräs keskeisimmistä tietoturvaan liittyvistä menetelmistä, joka on oikeuksien hallinta. Sillä pyritään estämään tiettyjen käyttäjä- tai tehtävärooliryhmien avoin pääsy kaikkiin ohjelmiston osiin. Tällöin hyökkääjät eivät voi, esimerkiksi C-kielellä koodatussa ohjelmistossa, rikkoa koko ohjelmistoa puskurin ylivuodon avustukselle. Käyttöoikeuksien hallinta on myös tehokas tapa estää hyökkääjää tuhoamasta, varastamasta tai muuntamasta tiedostoja kaikissa ohjelmiston osissa, vaan hän joutuu murtautumaan, joka osalle erikseen. Tämä siis ilmiselvästi ainakin vaikeuttaa hyökkääjän työtä merkittävästi. Ohjelmiston yhden osion heikkous ei siis kaada koko ohjelmistoa. Tietoturvamenetelmänä oikeuksien rajaamien on yleinen ja sitä voidaan käyttää virtuaalikoneilla, Unix sukuisissa käyttöjärjestelmissä, SSH:lla, Chrome-selaimessa ja web-palvelimilla. Oikeuksien hallinnalla voidaan hallita prosessin järjestelmäkutsuja. Tämä tarkoittaa käytännössä sitä, että järjestelmäkutsujen käyttö rajataan pois tietyiltä henkilöiltä, tietyissä tapauksissa. Tällaisia tapauksia voivat olla esimerkiksi objekteihin, kuten tiedostoihin, kansioihin, tietoliikenne rajapintoihin, prosesseihin, muistikomponentteihin, filedeskriptoreihin ja tietokoneen lisälaitteisiin kohdistuvat käyttötapaukset. Tiedostojen osalta tällaisia käyttötapauksia ovat: kirjoitus-, luku- ja suoritusoikeudet. Hakemistojen osalta ne ovat taas luomis-, nimeämis-, poistamis- ja muuttamisoikeudet. Kun uusi tiedosto tai hakemisto luodaan, käyttöjärjestelmä myöntää luvat sen käyttämiseen, sen luomalle käyttäjälle (user), ryhmälle (gruop) ja muille käyttäjille (others). Id-komennolla voi katsoa käyttäjän ID (UID), ryhmän ID (GID) ja kaikkien niiden ryhmien nimet, joihin kuulut. Jokaisella tiedostolla ja hakemistolla on luku-, kirjoitus- ja suoritusoikeudet erikseen eri käyttäjäryhmille: käyttäjä, ryhmä ja muut. Ne esitetään tyypillisesti kolmella oktaaliluvulla, jotka tarkoittavat eri käyttäjäryhmiä: käyttäjä, ryhmä ja muut. Oktaaliluvut toimivat hyvin, koska jokainen numero on 3 bittinen. Bitit tarkoittavat luku-, kirjoitus- ja suoritussoikeuksia. Esimerkiksi oktaaliluku 754 on bitteinä 111101100, ensimmäiset 3 bittiä (111) tarkoittavat, että käyttäjällä on luku-, kirjoitus- ja suoritusoikeudet, seuraavat 3 bittiä (101) tarkoittavat, että ryhmällä on luku- ja suoritusoikeudet ja viimeiset 3 bittiä (100) tarkoittavat, että muilla on vain lukuoikeudet. Näitä käyttöoikeuksia voi muuttaa vain objektin omistaja. Tämä tietoturvamenetelmä on vanha, mutta erittäin käyttökelpoinen vielä tänäkin päivänä. Filedeskriptori on abstrakti indikaattori pääsyoikeudesta johonkin tiedostoon sisälle, kun prosessi on avannut tiedoston luvallisesti, syntyy myös filedeskriptorin, ja sen avulla voi jatkaa tiedoston käyttämistä vapaasti. Prosessit voivat myös välittää filedeskriptoreita toisille ohjelmille UNIX domain soketin kautta. Tällainen elossa oleva välitettävä filedeskriptori kuulostaa todella merkittävältä tietoturvariskiltä, koska voiko taitava hyökkääjä pitää tällaista elossa pitkään ja levittää niitä haluamiinsa kohteisiin? Prosesseille voidaan tehdä seuraavia seuraavanlaisia toimenpiteitä, kuten esimerkiksi: debuggaus, signaalin lähettäminen, exit-statuksen odottaminen ja exit-statuksen saaminen. Debuggaukseen ja signaalin lähettämiseen tarvitaan sama käyttäjätunnus, kun taas exit-statuksen odottaminen ja exit-statuksen saaminen edellyttää, että pitää olla prosessin vanhempi. Muistien osalta oikeuksien hallinnassa käytetään rajana prosessia, toinen prosessi ei voi yleisesti nimetä muistipaikkoja toiseen prosessiin. Poikkeuksina ovat debuggaus mekanismit ja muistiinkuvatut tiedostot. Tämäkin on tietoturvan kannalta merkityksellistä, koska hyökkäyksien tekeminen voisi olla helpompaa, jos voisi sotkea toisen ohjelman muistipaikat. En tiedä olisiko tällainen hyökkäys mahdollista? Verkkojen osalta operaatiot ovat: portin avaaminen, osoitteeseen yhdistäminen, luku ja kirjoitus yhteys ja ”raakojen” pakettien lähetys ja vastaan ottaminen. Oikeuksien hallinnalle on useita sääntöjä, esimerkiksi ainoastaan juuri eli käyttäjä-ID nro 0, voi avata portteja joiden järjestysluku on alle 1024. Tällä saavutetaan se, että satunnainen käyttäjä ei voi ajaa web-serveriä, jonka portti on 80. Ainoastaan UID 0 saa lähettää ”raakoja” paketteja.  Kaikki prosessit saavat taas luoda yhteyden, mihin tahansa prosessiin.  Käyttöoikeuksien hallinnalla saavutetut hyödyt tietoturvan parantamisessa ovat kiistattomat. Tällaisten ominaisuuksien puuttuminen esimerkiksi web-palvelimilta olisi aika vaikeasti korvattavissa millään muulla tavalla. 
## Luento 6
Kuudennen videoluennon aihe on ohjelmien valtakirjat (eng. capabilities). Videoluento alkaa kuvaavalla esimerkillä ”confused depute” -ongelmalla, jossa ohjelmalla on valtakirja ylikirjoittaa jokin tiedosto, vaikka itse henkilöllä ei kirjoitusoikeutta olisikaan.  Esimerkissä kääntäjällä käännetään tiedosto ja muodostuneella tiedostolla ylikirjoitetaan saman niminen jo olemassa oleva tiedosto. Esimerkin tietoturvaongelma on todella olemassa. Kuudennella videoluennolla esitettiin myös sandboxing-suojaustekniikka, jolla käytettävät ohjelmat eristetään muusta järjestelmästä omaan hiekkalaatikkoonsa, jolloin ne eivät pääse käsiksi muihin tiedostoihin tai tekemään pysyviä muutoksia eri muisteihin. Sandbox-suojaustekniikka tuo tietokoneeseen ylimääräisen turvakerroksen tai palomuurin, tällöin ohjelman valtakirjat ja sitä mukaa oikeudet vähenevät. Sandbox-suojaustekniikkaa voidaan käyttää esimerkiksi web-palvelimissa (eng. lyh. OKWS) tai ohjelmissa, jotka käsittelevät verkkoyhteyksiä, etenkin niiden sisääntuloja. Sandbox-suojaustekniikkaa on myös hyvä käyttää ohjelmissa, joilla manipuloidaan dataa monimutkaisesti, kuten esimerkiksi seuraavilla ohjelmilla: gzip, Chromium, eri media koodekit ja selaimien lisäosat. Laitetaan monimutkainen ja usein epäilyttävä osa ”hiekkalaatikkoon”. Sandbox-suojaustekniikalla voi käyttää mitä tahansa ohjelmaa, jonka luotettavuus herättää epäilyjä, että siihen on saatettu piilottaa jokin virus. Erityisesti tulee mieleen käyttää tekniikkaa maksuttomien ohjelmistojen kanssa, joissa piilee usein vaara, että ohjelmisto paljastuu troijalaiseksi. Yksi vaihtoehto on, että ohjelmoijat alkavat ohjelmoimaan sovelluksensa siten, että ne käyttävät suoraan sandbox-suojaustekniikkaa hyväksi. Tämä toimii joissakin tapauksissa, kuten Javascript:llä, Java:lla ja Native Client:in kanssa. Tämän vuoksi olisikin syytä standardoida ympäristö Sandbox-koodin ajamiselle. Menetelmä kuulostaa toimivalta, olisiko siitä haittaa sovellukselle, jos jotkut sen osat toimisivat taustalla hiekkalaatikossa? Ei pitäisi olla. Sandbox-suojaustekniikan käyttäminen voi olla myös hyväksi, kun käytetään ohjelmia, joissa voi olla riski oikeuksien hallinnan kanssa. Tarkemmin sanottuna, että jos on olemassa riski, että hyökkääjä saa oikeuksien hallinnan sekaisin tai sitten tämä tapahtuu vahingossa. Voisiko sandbox-suojaustekniikkaa siis käyttää vaikkapa pelkästään tiedoston avaamiseen? Mitkä ovat siis sandbox-suojaustekniikan suojamekanismit ja onko niillä etuja ja rajoituksia? Käyttöjärjestelmä tarjoaa tyypillisesti joitakin primitiivisiä suojamekanismeja, kuten käyttäjä- ja ryhmätunnukset. mutta todelliset OS-tason sandbox-suojamekanismit luodaan prosesseihin. Ne toimivat hyvin koko prosessissa, jotka voidaan eristään yhdeksi kokonaisuudeksi.  Sovellus joudutaan kuitenkin usein ohjelmoimaan uudestaan, jotta prosessit saadaan eristettyä.  Myös muilla tekniikoilla voidaan luoda hienojakoista eristystä, näitä ovat esimerkiksi kooditason eristys Javascriptissa ja binäärinen instrumentaatio Native Client:issa. Usein näitä hienojakoisia ja OS-tason sandbox-suojatekniikoita käytetään yhdessä. Yksi Sandbox-tekniikka on kaiken virtualisointi, kun ajaa kaiken epäluotettavan koodin virtuaalisessa ympäristössä, niin pahaa ei pääse käymään. Tällä periaatteella on tehty monia ohjelmia, kuten x86 qemu, FreeBSD jails ja Linux LXC. Virtuaalikoneen käyttö estää kaiken lähes kaiken yhteydenpidon muun järjestelmän kanssa ja se on myös yhdistettävissä muiden eristystekniikoiden kanssa. Haittapuolena siinä on, että prosesseja, putkia tai tiedostoja ei pystytä jakamaan. Toinen negatiivinen asia on, että tekniikka on melko raskaskäyttöinen ja se aiheuttaa CPU:lle ja muisteihin viiveitä. Toinen sandbox-tekniikka on DAC (eng. Discretionary Access Control) eli harkinnanvarainen pääsyn hallinta. DAC-tekniikan ideana on luoda jokaiselle objektille, kuten tiedostoille ja hakemistoille, omat pääsyn hallinta listat, joiden avulla niihin pääsyä rajataan. Jokainen ohjelma käyttää jotakin oikeuksia, kuten UID, GID ja SetupID, kun ohjelma yrittää avata jonkin tiedoston, niin tätä yksittäistä pääsyä valvotaan erikseen, jos ohjelma kokee sen tarpeelliseksi. Kolmas sandbox-tekniikka on MAC (eng. Mandatory Access Control) eli pakollinen pääsyn hallinta eroaa DAC-tekniikasta siten, että sovellukset eivät voi itse päättää sitä, että valvotaanko yksittäistä pääsyä johonkin tiedostoon erikseen. Monet systeemit kuitenkin käyttävät, sekä MAC-tekniikkaa, että DAC-tekniikkaa.
## Luento 17
Seitsemännentoista videoluennon aihe oli käyttäjien autentikointi eri tietojärjestelmissä. Aiheen ydinhaasteena on se, miten ihmiset todistavat oman henkilöllisyytensä ohjelmalle. Salasanat ovat olleet yksi tietoturvan tärkeimmistä menetelmistä tietokoneiden synnystä asti ja ovat sitä vielä tänään ja huomennakin. Onko salasanojen korvaajaksi olemassa yhtään todellista korvaavaa tekniikkaa. Salasanat ovat yleisesti ottaen surkeita, niissä on alhainen entropia eli hyökkääjän on helppo arvata ne, ja kun salasanan unohtaa pitää vastata turvakysymyksiin, jotta ne saadaan uusittua. Turvakysymyksien entropia on myös alhainen. Näiden kahden heikkouden lisäksi, ovat vielä käyttäjät itse. Tietoturvaa ei lisää myöskään se tieto, että käyttäjät laittavat samoja salasanoja useille eri sivustoille. Videoluennon luennoija jopa sanoo, että ”Salasanojen jatkuva dominointi, muihin metodeihin verrattuna, on suuri häpeä koko tiedeyhteisölle.” Mutta mikä salasana sitten todella on? Se on salaisuus, jonka tietävät käyttäjä ja palvelin. Naivissa implementaatiossa palvelimella on taulukko, joka yhdistää käyttäjänimet ja salasanan merkkijono muodossa. Tämän ongelmana on se, että jos hyökkääjä pääsee murtautumaan palvelimelle, hän saa kaikki käyttäjätunnus salasana parit mukaansa. Tämä todellakin kuulostaa riskialttiille menetelmälle. Todellisuudessa tässä käytetäänkin apuna hajautusta, jolloin palvelimelle tallennetaan käyttäjänimi ja pitkä hajautettu merkkijono, joten hyökkääjä ei voi saada suoraan käyttäjätunnus salasana pareja selville. Etuna on vielä, että hajautusfunktio ovat myös hankalia kääntää, joten edes raakaan laskentatehoon perustuvat salasanojen murtamismenetelmät eivät toimi. Ongelmana on se, että hyökkääjän ei tarvitse käyttää tehottomia raakaan voimaan perustuvia menetelmiä kaikkiin mahdollisiin salasanoihin, vaan todellisuudessa käytettyjen salasanojen joukko on todella pieni. Jonkin tutkimuksen mukaan 5000 salasanaa peittää 20% käyttäjistä. Palvelin voi käyttää myös laskennallisesti raskasta derivaatio funktiota salasanojen hajautuksessa. Tällaisia funktioita ovat esimerkiksi BCrypt ja PBKDF2. Tämänkin murtamiseen hyökkääjillä on oma konsti, nimittäin ”sateenkaaritaulukot”. Nämä sateenkaaritaulukot ovat salasana-hash taulukoita. Ne antavat hyökkääjälle mahdollisuuden selvittää hajautukset jälkikäteen, tämä laskenta on tosin melko hidasta. Palvelimen kannalta parempi ratkaisu on taas käyttää salasanojen suolausta, joka tarkoittaa sitä, että hajautuksessa käytetään salasanan lisäksi satunnaislukua. Satunnaisluku tallennetaan palvelimelle, joten hyökkääjä saa senkin selville, jos haluaa? Hyökkääjä ei voi kuitenkaan käyttää vain yhtä sateenkaaritaulua hajautus tulosten selvittämiseen, koska samalla salasanalla ja eri suolalla on eri hajautusarvo.  On parasta valita pitkä satunnainen suola ja vaihtaa suolaa aina, kun salasana vaihdetaan uudeksi. On myös muistettava, että salasanaa ei saa lähettää palvelimelle suojaamattomana. Raakaan voimaan perustuvilta salasanojen murtamismenetelmiltä voidaan taas suojautua menetelmällä, joka estää ”vasaroinnin”. Tämä tapahtuu estämällä salasanojen loputtomat uudelleen yritykset ja asettamalla viive, minkä jälkeen salasanaa voi kokeilla uudelleen. On tärkeää säädellä arvaustaajuutta, koska salasanojen entropia on niin heikko. Monilla sivuilla on käytössä sääntöjä, joiden mukaan salasanat tulee kirjoittaa, niissä voidaan määrätä esimerkiksi salasanan pituus, merkkejä jne. Todellisuudessa hyökkääjä voi kuitenkin myös soveltaa sääntöjä omissa sateenkaaritaulukoissaan ja säännöt eivät muutu paremmaksi entropiaksi. Mitä muuta voidaan käyttää salasanojen tilalla? Biometrisia tunnisteita, kuten sormenjälkeä, iiriksen skannausta ja äänen tunnistusta, mutta niillä on harvoin parempi entropia, kuin salasanoilla. Joskus autentikoinnissa onkin hyvä käyttää eri äänen tunnistusmenetelmien yhdistelmiä, jolloin entropia on huomattavasti parempi.  Onkin aika erikoista kuulla, että esimerkiksi sormenjäljen tai iiriksen skannauksen entropia on yhtä huono kuin salasanan entropia. Mistä tämä voi johtua, eivätkö nämä olekaan ainutlaatuisia, vai millä tavalla hyökkääjä voi käyttää tätä hyväksi? Miten hän murtautuu ja ohittaa esimerkiksi iiris skannauksen ja pystyy pääsemään sisälle järjestelmään? 
## Luento 10
Kymmenennen videoluennon aiheena oli symboliset suoritukset (eng. Symbolic Execution). Aihe kertoo tietokoneohjelmien staattisista tarkastusmenetelmistä, joilla yritetään lisätä ohjelmien tietoturvan tasoa. Symbolisessa suorituksessa jokaisen muuttujan tila esitetään symboleiden avulla. Ohjelma on polku ja haarakohdat ovat esimerkiksi if-lauseita. Kaikista mahdollisista poluista tarkastellaan tulosteet, jotka saadaan aikaan symbolisella suorittamisella. Jokaisesta suoritetusta polusta kerätään tietoa, että mitä juuri siinä kyseisessä polussa tapahtuu. Jokaisesta polusta saadaan symbolisesti esitetty lauseke vastaaviin ohjelman syötteisiin. Ohjelmasta etsitään yleisesti tietoa, että voiko ohjelman saada vahingossa kaadettua, vaikka joillain tietyillä peräkkäisillä syötteillä. Ohjelmista etsitään myös tietoturva-aukkoja antamalla virheellistä dataa, joka voi olla liian suurta, liian pientä, tai merkkejä, joita ei normaalisti kuuluisi antaa. Tarkastusmenetelmä kuulostaa erittäin toimivalta ja videoluennon esimerkki oli myös helppolukuinen ja se vaikutti erittäin implementointi kelpoiselta. Näillä staattisilla tarkastuksilla voidaan tarkastaa myös tietokoneohjelmien syötteiden oikeellisuutta ja estää hyökkääjää esimerkiksi injektoimasta syötteiden sekaan sinne kuulumattomia merkkejä. Staattisista tarkastusmenetelmistä voisi saada apua myös muihin tietoturva ongelmiin, kuten hyökkääjän suorittamiin puskureiden ylivuotoihin, kun tarkastus implementoitaisi oikeaan kohtaan. Pitäisikö esimerkiksi Baggy Bound Check tai muut rajojen tarkastusmenetelmät laskea mukaan staattisiksi tarkastusmenetelmiksi? SMT:tä (eng. Satisfiability Modulo Theories) toteutuvuus modulo teorioita ja SAT:ia (eng. Propositional Satisfiability Problem) lauseloogista toteutuvuusongelman tarkastusta käytetään syötettyjen kaavojen toteutuvuuden selvittämiseen. Ongelma on ratkeava, jos sille on olemassa polynomisessa ajassa toimiva ratkaisualgoritmi. Onkin huomattava, että osa ongelmista ei ratkea ikinä ja ne ovat niin kutsuttuja NP-täydellisiä ongelmia. Yksi näistä uuden sukupolven tarkastus työkaluista on Cristian Cadarin et al. artikkelissa ”Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs” esitetty, symbolista suoritusta hyväksikäyttävä, työkalu KLEE, jolla on kaksi pää tehtävää. Ensimmäinen päätehtävä on testata ohjelman kaikki koodirivit ja saada aikaan mahdollisimman hyvä kattavuus ohjelmiston koodiin. Toinen päätehtävä on saada kiinni kaikki virhetilanteet. KLEE: n ydin on tulkkisilmukka, joka valitsee suoritettavan tilan ja suorittaa symbolisesti yksittäinen käskyn kyseisessä tilassa. Silmukka jatkuu, kunnes kaikki tilat ovat käyty läpi tai käyttäjän asettama aikaraja on saavutettu. KLEE käsittelee siis valtavan määrän eri tiloja, jo pienissäkin ohjelmissa voi olla jopa 100 000 eri tilaa. Kun KLEE:llä testattiin eri ohjelmia, niin se sai kiinni 452 testatusta ohjelmasta 56 pahaa virhettä. Näistä kolme sijaitsi GNU:n ydintyökaluissa ja ne olivat olleet osana ohjelmistoa jo 15 vuotta. KLEE:llä on monia muitakin hyviä ominaisuuksia, yksi näistä on se, että KLEE:llä saadaan katettua jopa 90,5 prosenttia ohjelman koodista, joissain testatuissa ohjelmista saatiin täydet 100 prosenttia. KLEE saavutti paremman kattavuuden, kuin ohjelmoijien itsensä tekemät ohjelmat. KLEE toimi myös, yhtä poikkeusta lukuun ottamatta, ilman koodi muutoksien tekemistä testattavaan ohjelmaan.  KLEE:llä testaaminen tapahtuu suoraan raakakoodilla, esimerkiksi koodilla, joka on käännetty gcc-kääntäjällä. Tämä ominaisuus auttaa korjaamaa virheet nopeasti, vaikka KLEE voi testata myös korkeamman tason koodia. Myös sellaisen koodin testaaminen onnistuu, joka ei ole peräisin sovelluksesta. Kun KLEE:llä esimerkiksi testattiin HiStar ydintä, niin se löysi monta vakavaa virhettä myös siitä. KLEE:llä on kuitenkin myös samat huolet, kuin muillakin vastaavilla ohjelmilla, eli eksponentiaalisen suuri polkujen määrä, ja ympäristön, kuten käyttäjien, käyttöjärjestelmien ja verkon välinen vuorovaikutus. KLEE vaikuttaa erittäin toimivalta ratkaisulta ohjelmiston testaukseen ja sillä saavutetut tulokset ovat vaikuttavia. Tuleekin mieleen, että miksi ohjelmoijat vaivautuvat kuluttamaan aikaa omien testausohjelmien tekemiseen, kun on olemassa valmiita näinkin toimivia ratkaisuita.
## Luento 8
Kahdeksas videoluento kertoo webbi-sovellusten tietoturvasta, mikä se Webbi sitten edes on? Ennen se oli yksinkertainen asiakas – palvelinarkkitehtuuri, asiakas oli verkkoselaimesi ja palvelin oli verkossa oleva kone, joka pystyi tuottamaan staattista tekstiä ja kuvia selaimeesi. Ennen palvelimen puoli oli paljon monimutkaisempi, kuin selaimen puoli. Selaimet eivät tukeneet ennen rikkaita vuorovaikutteisia web-tekniikoita, mutta palvelimet saattoivat olla yhteydessä esimerkiksi tietokantoihin ja muihin palvelimiin. Webin tietoturva keskittyi ennen palvelimen puolelle, koska se oli niin paljon monimutkaisempi. Tyypillisiä haasteita ovat olleet esimerkiksi puskurien ylivuodot web-palvelimissa ja oikeuksien hallinta web-palvelimilla. Mutta nykyään web on muuttunut. Nyt selaimen puoli onkin se monimutkaisempi ja haastavampi puoli tietoturvan näkökulmasta. Esimerkiksi JavaScriptin avulla voidaan suorittaa koodia selaimessa asiakkaan puolella. DOM-malli (eng. Document Object Model) tarjoaa JavaScript rajapinnan verkkosivun HTML:lle, jonka avulla verkkosivu voi esimerkiksi lisätä ja poistaa tagejä ja muuttaa tyyliään. JavaScriptiä voidaan käyttää myös monisäikeisesti. AJAX tarjoaa asynkronoidut HTTP-pyynnöt. Web-sokettien avulla voidaan taas luoda kaksisuuntainen TCP-yhteys asiakkaan ja palvelimen välille. JavaScriptiä voidaan ajaa nykyään myös monisäikeisesti. Selaimet voivat määrittää asiakkaan sijainnin GPS-tietojen perusteella ja Firefox, jopa wifi-informaation perusteella, kun se lähettää ne Googlen paikkapalveluun. Eli webbi on nykyään monimutkainen alusta, jossa käytetään hajautettuja palveluita ja laskentaa, joka asettaa tietenkin myös suuria haasteita tietoturvalle, koska riskejä on valtavasti. Yksittäinen verkkosivu voi käyttää nykyään useita eri ohjelmointikieliä, käyttöjärjestelmiä ja laitealustoja. Esimerkiksi Firefoxin selainta voidaan käyttää Windowsin käyttöjärjestelmässä, joka on yhteydessä Linuxia palvelimeen, joka käyttää Apachea ja on yhteydessä memcached:in ja MySQL:n kanssa. Tuntuukin, että miten näin monimutkaisessa järjestelmässä voidaan taata tietoturvallisuus, kun pelkästään sovelluksen ymmärtäminen on vaikeaa. Webbi speksit ovat sitä paitsi huomattavan pitkiä, erittäin monimutkaisia, joskus jopa ristiriitaisia ja ne kehittyvät koko ajan. Mutta miten sitten pystytään eristämään eri palveluntarjoajien tarjoamaa sisältöä? Tavallisen tietokoneohjelman ja web-sovelluksen ero on siinä, että bitit tulevat tavallisessa ohjelmassa yhdeltä palveluntarjoajalta, joko Windowsilta tai Applelta, mutta yksi web-sovellus taas koostuu monien eri palveluntarjoajien säännöistä ja periaatteista. Täysin riskittömän sovelluksen aikaansaaminen, tällaisessa muuttuvassa ympäristössä, on varmaan mahdoton haave? Epämääräinen haave voisikin olla, että kaksi eri verkkosivusto ei voisi peukaloida toistensa sisältöä, koska eihän se olisi hyvä, jos toinen sivusto voisi muuttaa toisen sivuston visuaalisen ulkonäön, mutta kuitenkin on hyvä, jos kehittäjät voivat luoda mash-up sivuja, joissa on materiaalia useilta eri verkkosivustoilta. Perusstrategiana voisi olla saman alkuperän politiikka, jossa selain määrittelisi alkuperän jokaiselle resurssina olevalle sivulle, jotka sisältäisivät myös JavaScript-kirjastot ja näin JavaScript-koodi voisi olla yhteydessä vain siihen sivustoon, josta se on kotoisin. Alkuperän voi määritellä esimerkiksi, rakenne, verkkosivuston nimi ja portin numero, esim. HTTPS, foo.com, 80. Jokainen alkuperä yhdistetään asiakas puolen resurssiin, kuten evästeisiin, DOM-varaston, JavaScript-nimiavaruuden, DOM-puun, Windowsin, visuaalisen näytön tilan tai verkko-osoitteiden kanssa. Evästeiden kontrollointi on tärkeää, koska muuten hyökkääjä voi pakottaa käyttäjän käyttämään tiliä, joka on hyökkääjän hallussa. Alkuperä on Unix-järjestelmässä sama asia kuin UID. Jokainen kehys saa t alkuperänsä verkkosivuston yksilöivästä osoitteesta, tämä on moraalisesti sama asia Unix-järjestelmässä, kuin prosessi. Skriptejä lisäävät kehykset toimivat taas kyseisen HTML-tiedoston alkuperällä. Tämä toimii molemmille, sekä sisäisille, että ulkopuolelta tuleville skripteille. Unix-järjestelmässä sama asia olisi ajaa tiedostoa, joka on tallennettu jonkun muun hakemistoon. Passiivinen sisältö, kuten kuvat ja CSS eivät voi ajaa koodia, joten niille ei anneta mitään oikeuksia. Tämä järjestely kuulostaa ihan hyvälle ja uskoisin, että hyökkääjän työ vaikeutuu merkittävästi, jos tällainen turvamekanismi on käytössä.
## Luento 9
Yhdeksäs videoluento jatkaa samasta aiheesta, kuin edellinenkin videoluento, eli web-sovellusten tietoturvasta. Web-sovellusten tietoturvan päämekanismina toimii edelleen saman alkuperän politiikka. Viime aikoina levinnyt ”Shell Shock”-vika on hyvä esimerkki siitä, miten vaikeaa on suunnitella web-palvelu, joka yhdistää useita eri tekniikoita. Webin asiakasohjelma voi esimerkiksi lisätä otsikoita http-pyyntöihin ja päättää itse, mitkä parametrit kyselyssä ovat mukana.  CGI-palvelimet kartoittavat useita eri komponentteja http-pyynnöistä aina Unix-ympäristön muuttujiin. Yksi järjestelmän haavoittuvuus on se, että Bash-komentotulkissa on jäsennysongelma tavassa, jolla se käsittelee ympäristömuuttujia. Jos merkkijono esimerkiksi alkaa tietyillä epämuodostuneilla biteillä, niin Bash jatkaa merkkijonon jäsentämistä ja suorittaa kaikki komennot, jotka se vain löytää. Jos esimerkiksi syöttää ympäristömuuttujan, joka alkaa näin:  {  .;};  /bin /id, niin se sekoittaa Bashin jäsentäjän ja aiheuttaa /bin /id käskyn suorittamisen. Käsky näyttää nykyisen käyttäjän UID:n ja  GID:n. ”Shell Shock”-vika on ilmentymä tietystä tietoturvan vikatyypistä, joka on seurausta riittämättömästä puhdistuksesta.  Toinen riittämättömästä puhdistuksesta aiheutuva vika on XSS (eng. Cross-site Scripting Attack) poikki sivun kulkeva skripti hyökkäys. Voidaan esimerkiksi ajatella, että CGI-skripti yhdistää tai sulauttaa luomaansa HTML:n mukaan jonkin kyselyn tekevän merkkijonon. Mutta miksi tämä XSS-hyökkäys on niin hallitseva? Dynaamiset verkkosivut yhdistävät käyttäjäsisältöä html-sivuille, esimerkiksi kommenttiosioon. Verkkosivut myös isännöivät käyttäjän lataamaa sisältöä, jossa html-dokumentit voivat sisältää mielivaltaista Javascript koodia, jolla voidaan ajaa suoraan koodia, joka on peräisin jostain tuntemattomasta lähteestä. Hyökkäystyyppi vaikuttaa erittäin vakavalta ja sillä pystytään luultavasti suorittamaan lukuisia eri tyyppisiä hyökkäyksiä, kuten erilaisia puskurin ylivuotoja. XSS-hyökkäykseltä voidaan myös puolustautua, esimerkiksi Chrome ja Internet Explorer käyttävät hyväksi sisäänrakennettua heuristiikkaa, millä ne havaitsevat XSS-hyökkäyksiä. On olemassa joitakin vahvoja indikaatioita siitä, että jotain epäilyttävää tulee tapahtumaan. Tällainen epäilyttävä tapahtuma on esimerkiksi, jos skripti, joka aiotaan kohta suorittaa, sisältyy http-pyyntöön, joka juuri haki ympäröivän verkkosivun. Edellinen esimerkki on niin kutsuttu heijastunut XSS-hyökkäys (eng. Reflected XSS Attack), jossa palvelin heijastaa hyökkääjän toimittaman likaisen koodin käyttäjän selaimelle ja suorittaa sen sitten uhrisivun kontekstissa.  Selaimien suojaus filtterit eivät toimi 100% varmuudella, koska XSS-hyökkäyksiä voidaan koodata niin usealla eri tavalla. Filtterit eivät myöskään saa kiinni sinnikkäitä XSS-hyökkäyksiä, joissa palvelin tallentaa hyökkääjän tarjoamaa dataa, joka sitten pysyvästi levitetään asiakkaille. Klassinen esimerkki tällaisesta hyökkäyksestä on verkkosivuston kommenttiosio, joka antaa käyttäjien postittaa html-viestejä. Toinen esimerkki voisi olla deittisivusto, joka antaa käyttäjien tallentaa html-kieltä heidän profiileihinsa. Hyökkääjä voisi lisätä html-kieltä, joka käyttäisi käyttäjän toista selainta, kun hän katsoisi hyökkääjän sivustoa, sitten hyökkääjä voisi anastaa käyttäjän evästeet. Toinen tapa estää XSS-hyökkäys on käyttää ”vain http”-evästeitä, jossa palvelin voi kertoa selaimelle, että asiakaan puolen JavaScript-koodilla ei pääse käsiksi evästeisiin. Oikeuksien hallinnalla voidaan erottaa domain epäluotettavasta sisällöstä. Esimerkiksi google säilyttää epäluotettavaa käyttäjiltä peräisin olevaa dataa eri domainin alla, joka on nimeltään googleusercontent.com Kolmas tapa XSS-hyökkäyksiä vastaan on puhdistaa sisältö epäilyttävästä datasta, siivoamalla kaikki merkkijonot. Tämä menetelmä kuulostaa tehokkaalta ja toimivalta ratkaisulta. Sisällön tietoturvapolitiikka (CSP) voi myös auttaa asiakasta lataamasta väärän tyyppistä sisältöä väärältä sivustolta. Verkkosivustot ovat myös haavoittuvaisia ”selittämätön kanava” -hyökkäyksille, jollainen pääsee tapahtumaan, kun kaksi sovellusta pääsee vaihtamaan tietoa keskenään, vaikka tietoturvamalli kieltää sovellusten keskustelemasta keskenään.  Kanavaa kutsutaan selittämättömäksi, koska se ei käytä perinteisiä mekanismeja sovellusten väliseen viestintään. Toisaalta kaikki hyökkäykset ovat jossain määrin selittämättömiä, ennen kuin ne ovat tutkittu. Tällaisia hyökkäyksiä vastaa on varmaan todella vaikea taistella.
## Luento 18
Kahdeksannentoista videoluennon aihe oli ”yksityinen selailu”, jossa selailulla tarkoittaa nimenomaan verkon selaamista web-selaimella. Mitä tarkoitetaan selailun yksityisyydellä? Epämääräisesti sanottuna ideaalitilanne on kysymyksessä silloin, kun yksittäistä käyttäjää on mahdotonta erottaa monesta muusta käyttäjästä. Selailun yksityisyydelle ei ole olemassa kuitenkaan formaalia määritelmää, osaksi siitä syystä, että web-sovellukset ovat niin monimutkaisia ja silloin tulee helposti syyllistettyä niitä. Web-selaimet taas päivittävät implementaatiotaan sen mukaan, mitä ihmiset haluavat. Selaimien valmistajat seuraavat myös toisiaan. Mitä selaimet siis ajattelevat yksityisestä selailusta? Artikkeli jakaa asian kahteen eri uhkakuvaan ja hyökkäystyyppiin. Ensimmäinen näistä on paikallinen hyökkääjä, joka ottaa koneesi hallintaansa, kun olet lopettanut selailun. Sitten hän selvittää ne verkkosivut joilla vierailit käyttäessäsi selainta. Toinen uhkakuva on web-hyökkääjä, joka on murtautunut web-palvelimelle, jonka kanssa olet yhteydessä. Hyökkääjä haluaa linkittää sinut yksityiseen ja/tai normaaliin sessioon. Kun nämä kaksi hyökkääjää tekevät yhteistyötä, niin heidän on helpompaa saada selville sinun identiteettisi. Paikallinen hyökkääjä kysyy palvelinta tarkastamaan kaikki paikalliset IP-osoitteet palvelimen yhteyslogista. Ensimmäinen uhkakuvan olettamus on, että hyökkääjä selvittää ne verkkosivut joilla vierailit. Tietoturvan tavoite on taas, että hyökkääjä ei saa selville noita osoitteita.  Mutta mitä tietoa yksityinen web-selailu sessio voi sitten vuotaa ulos: Evästeitä, DOM-varastoja, selaimen välimuistin, selailun historiatiedot, kirjanmerkit, selaimen lisäosat, konfiguraation tilat ja ladatut tiedostot. Yksityisen selailun suojamekanismit yrittävät estää evästeiden, välimuistin ja historiatietojen tallentamisen paikalliseen muistiin, myös verkko aktiviteetit voivat jättää todisteita, kuten DNS-resoluutio tallenteen. Tämän ongelman ratkaisemiseksi, yksityisen selailun tila joutuisi tyhjentämään selaimen välimuistin, kun selailu lopetetaan. Mutta tätä varten selain tarvitsisi ylläpitäjän oikeudet järjestelmään. Ei ole kuitenkaan kovin viisasta antaa näitä oikeuksia selaimelle, koska muuten vasta ollaankin luotu todellinen mahdollisuus hyökkääjille. Yksityisen selailun aikana myös RAM-muistin sisältö voi joutua paikalliselle levylle. Missä data sitten oleilee? Se voi olla missä vain: prosessin muistissa, keossa, pinossa, terminaalin takaisinvierityksessä, I/O-puskureissa, tapahtumakyselyissä, DNS välimuistissa proxy-palvelimella, muuttumattomissa merkkijonoissa, tiedostoissa, varmuuskopioissa, tietokannoissa, heittovaihtotiedostoissa ja ytimen muisteissa. Näistä paikoista hyökkääjä yrittää saada tiedon itselleen, kun ajattelee, että miten paljon näitä eri paikkoja on piilottaa saastunutta tietoa tai etsiä koneesta kiinnostavaa tietoa, niin ymmärtää miten haasteellisesta asiasta tietoturvassa on kyse. Hyökkääjälle on olemassa erittäin monta hyvää piilopaikkaa. Muistit pitäisi siis ainakin nollata aika-ajoin ja salauksen käyttäminen voisi olla järkevää, jos nollaus ei onnistu. Toisessa uhkakuvassa hyökkääjä piileskelee palvelimella, joissa käyttäjä vierailee. Toisina olettamuksina ovat, että hyökkääjä ei kontrolloi käyttäjän konetta ja, että hyökkääjä haluaa tietää, milloin käyttäjä käy jollakin tietyllä sivustolla. Tietoturvan näkökulmasta on tärkeää, että hyökkääjä ei saa identifioitua käyttäjää ja myös yksityisen selailun käyttäminen pitäisi jäädä pimentoon. Tällaisen web-hyökkääjän torjuminen on erittäin hankalaa. Hän pystyy identifioimaan käyttäjän monesta asiasta. Yksi tapa on linkittää käynnit sivustoilla, jotka tapahtuvat monessa eri sessiossa, julkisissa ja yksityisissä. Toinen tapa on IP-osoite, joka onkin helppo ymmärtää. Kolmas tapa on analysoida selaimen käyttöä, koska jokaisella käyttäjällä on siihen omat piirteensä ja tapansa.  Suojautumiseen on muutama hyvä tapa. Ensimmäinen on käyttää virtuaalikonetta ja varmistaa, että se tuhotaan käytön jälkeen. Tämä tapa on melko raskas ja vaikea menetelmä, jos sitä joutuu käyttämään päivittäin. Toinen tapa on OS-tason yksityisyys, jossa prosessia voi ajaa ”yksityisessä domainissa”, joka tuhotaan käytön jälkeen. Molemmat tavat kuulostavat jotenkin hankalilta käyttää ja en jaksa uskoa, että niitä käytettäisiin laajemmin tulevaisuudessakaan, ainakaan jos niille ei ole erityistä tarvetta.
## Luento 7
## Luento 21
Kahdeskymmenesensimmäinen videoluento oli aiheeltaan datan seuraaminen (eng. data tracking). Sovellukset yrittävät usein lähettää käyttäjän yksityisiä tietoja palvelimille ja tätä ongelmaa datan seurannalla yritetään sitten selvittää ja kaikkein sensitiivisintä dataa voidaan seuraamisen lisäksi yrittää estää, että se ei joutuisi ulos laitteesta. Android-käyttöjärjestelmässä on omat oikeudet, joilla voidaan määritellä, mitä sovelluksella voidaan lukea ja kirjoittaa, tai mitä laitteita ja resursseja voidaan käyttää. Kun käytetään Androidin oikeuksia, on vaikeaa määrittää esimerkiksi osittaisten datatyyppien kontrolli. Tämä tarkoittaa, että vaikka Android-sovelluksella olisikin oikeus käyttää verkkoa, niin se ei kuitenkaan saisi lähettää käyttäjän dataa verkon yli. Jos taas ei ikinä asentaisi sovelluksia, joilla on sekä lukuoikeus, että oikeus käyttää verkkoja, niin voisi menettää monta erityisen tärkeää sovellusta, kuten esimerkiksi sähköpostin. Informaatio voi vuotaa vääriin käsiin myös muita kanavia pitkin, kuten esimerkiksi selaimen välimuisti vuotaa siitä huolimatta vaikka, että objekti on haettu aikaisemmin. Sovellukset voivat tehdä myös yhteistyötä, kun toinen sovelluksista on saanut verkko-oikeudet, niin se voi lähettää dataa sellaiselle sovellukselle, jolla ei ole verkko-oikeuksia. Haittaohjelma voi huijata toisen sovelluksen lähettämään dataa jonnekin luvattomaan paikkaan. Mutta mitä sitten Androidin haittaohjelmat ylipäätään tekevät. Ne voivat käyttää paikkaa tai uniikkia IMEI-laitetunnusta mainostamiseen. Ne voivat varastaa ja välittää laitteessa olevia tietoja, kuten yhteystietoja, IMEI-koodin tai puhelinnumeron palvelimelle. Ne voivat käyttää puhelintasi myös palvelunestohyökkäyksiin tai lähettää roskapostia yhteystiedoissa oleviin osoitteisiin. Ei ole siis hyvä päästää dataa karkaamaan pois älylaitteista, mutta pelkkä datan seuraaminen ei siis riitä estämään laitteiden hakkerointia. TaintDroid on yksi tällainen ohjelma, joka seuraa arkaa dataa, kun se tunkeutuu systeemin lävitse. Ohjelma erottaa datan lähteet ja datan ulosmeno kohdat toisistaan. Datan lähteitä voivat olla sensorit, kontaktit ja IMEI, kun taas data virtaa kohti ulosmeno kohtaa, joka on verkko. TaintDroid käyttää 32 bittistä bittivektoria kuvaamaan saastumista, joten erilaisia saastumisen lähteitä voi olla jopa 32 erilaista. 
