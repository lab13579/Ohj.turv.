# Ohj.turv - Luentopäiväkirja
Tehnyt R.Immonen 

## Luento 1
Ensimmäisellä videoluennolla käydään läpi MIT:n tietojärjestelmien tietoturvallisuus kurssin aiheita yleisesti, sekä tietoturvallisuuden merkitystä, miksi se on yleisesti ottaen niin hankalaa, ja mitä se vaatii, että pystytään ohjelmoimaan tietoturvallisesti ja osataan näin toteutettua tietoturvallinen ohjelmisto. Tietoturva on yleisesti johonkin maaliin pyrkimistä, kun hyökkääjä vaanii kulman takana. Tämä on totta, maaliin ei päästä, jos reitillä kaadutaan johonkin hyökkääjän tekemään ansaan. Tietoturvamallin ensimmäinen osa on tietoturvapolitiikka: luottamuksellisuus, eheys ja saatavuus, kaikki nämä kohdat ovat toteuduttava, vaikka uhkia on joka puolella.  Tietoturvamallin toinen osa on uhkakuvat, olettamuksista mitä hyökkää pystyy ehkä tekemään. Hyökkääjät yllättävät usein ja myös he kehittyvät ja opiskelevat uusia tekniikoita. Tämä on tärkeä kohta, että osataan varautua oikeisiin uhkiin, eikä myöskään yli varauduta, koska se on kallista.  Tietoturvamallin kolmas osa ovat mekanismit: ohjelmistot, komponentit ja systeemit. Näillä mekanismeilla pyritään toteuttamaan voimassaolevaa tietoturvapolitiikkaa, niin kauan, kun hyökkääjä kykenee tekemään vain uhkakuvissa oletettuja hyökkäyksiä.  
Tietoturvapolitiikka voidaan tuhota helposti, se voidaan tuhota samalla tavalla, kun ensimmäisellä MIT:n videoluennolla läpikäydyssä esimerkissä.  Siinä kolmen eri verkkosivuston erilainen tietoturvapolitiikka ja toimintatavat aiheuttivat yhdessä tietoturva-aukon yhdelle verkkosivustolle. Esimerkki oli erittäin mielenkiintoinen ja tuokin selvästi esille tarpeen luoda yhtenäisiä käytäntöjä verkkosivustoille sisäänkirjautumisiin ja salasanojen vaihtoon. Itselläni oli vasta samanlainen kokemus PayPal-sivuston salasanan uusimisen ja kyseisen verkkosivun varmennustapojen kanssa. Ensimmäinen ja toinen varmennustapa, eivät toimineet kohdallani, koska puhelinnumeroni oli muuttunut ja en pystynyt vastaamaan puheluun tai tekstiviestiin. Kolmas varmennustapa oli turvakysymykset, joita en ollut ilmeisesti kirjoittanut ylös. Viimeinen varmennustapa oli tietää luottokortin koko numero kahden viimeisen numeron perusteella, joka ei tietenkään myöskään toiminut kohdallani, koska luottokortti oli välillä uusittu. Tällä tavalla kaikki varmennustavat pettivät kohdallani. Siitä tulikin mieleen, että voisikohan tulevaisuudessa käyttää pankkitunnuksia, kuvallista henkilökorttia tai jotain perinteisempiä tapoja hyväksi varmennuksessa ja pitäisikö tähän tarkoitukseen olla omia yrityksiä, jotka tarjoaisivat standardisoitua varmennuspalvelua muille verkkokaupoille. Muutoin on varmaan vaikeaa saada näitä varmennustapoja yhdenmukaistettua. Uhkakuvatkin voidaan arvioida väärin, koska ihminen on arvaamaton ja tekee asioita, joita on vaikea ennustaa. Toinen asia, joka on vaikea ennakoida, on tekniikan kehitys. Esimerkiksi nykytekniikan avulla voidaan murtaa vanhat salasanat jo hyvinkin tehokkaasti. Olettamusten on siis hyvä seurata aikaa ja teknologian evoluutiota. Tietoturvamallin osista mekanismit ovat helpoimpia todeta, joka toimiviksi tai sitten toimimattomiksi. Toimimattomista mekanismeista on hyvä esimerkki videoluennolla toiminut esimerkki Applen iCloud:sta, jossa koodaaja oli unohtanut laittaa salasanan kyselyyn aikarajoituksen, miten usein väärin syötettyä salasanaa voi vaihtaa ja kokeilla uudelleen. Nykytekniikan avulla onkin hyvin mahdollista, että kokeilemalla lukuisilla eri salasanoilla voi päästä murtautumaan sisälle web-sivustolle jo yhden päivän aikana. Tämä johtuu siitä, että ihmiset valitsevat usein ennustettavia eli huonoja salasanoja. Toinen hyvä esimerkki oli C-kielen merkkijonon lopetusmerkin hyväksi käyttäminen SSL-sertifikaatin väärentämisessä ja käyttöön saamisessa. Siinä merkkijonon lopetusmerkin \0 avulla saatiin siirretty SSL-sertifikaatti kaapatulle sivulle oman sivun sertifikaatin avulla. Jälleen hyvä esimerkki ihmisen kekseliäisyydestä ja ennalta arvaamattomuudesta. Luentovideolla esitetään myös kysymys, että onko SSL-sertifikaatteja myöntävät yritykset CA:t (eng. Certificate Authority) kaikki niin turvallisia, että niihin voi luottaa. Kuka takaa, että sadat CA:t ovat suojanneet yhteytensä ja järjestelmänsä niin, että niistä yhdestäkään ei löydy mitään moitittavaa. Varmaan ihan aiheellinen kysymys tämäkin. Luennosta jäi mielikuva, että mitä tahansa voi tapahtua ja kehenkään ei voi luottaa, koska jos perinteiset hakkerit nukkuvat, niin ainakin NSA valvoo, tarkkailee ja tunkeutuu koteihimme tietokoneiden kautta.  

## Luento 2
Toisen videoluennon aihe on ”kuinka hallitset kaappaushyökkäyksiä”. Aluksi videoluennolla käydään läpi ylivuotoja yleisesti, niiden ehkäiseminen on vielä tänäkin päivänä yhtenä päähaasteena tietoturvan parantamisessa. Mahdollisuus ylivuodoille on vieläkin olemassa, vaikka niiden ehkäisyyn on kehitetty monia eri menetelmiä ja että näitä menetelmiä voidaan käyttää myös ristiin toistensa kanssa. Pääsyynä ylivuotojen olemassaololle on C:n ja C++:n kaltaiset matalantason ohjelmointikielet, joita on käytetty ja tullaan käyttämään vielä pitkään eri laitteissa ja sovelluksissa. Nämä kielet ovat käytössä etenkin sulautetuissa järjestelmissä, tietoliikenne komponenteissa ja tulevaisuuden IoT-laitteissa, joiden määrä tuleekin lisääntymään räjähdysmäisesti. IoT-laitteet tulevat olemaan myös tietoturvan näkökulmasta riskialttiita, koska ne liittyvät koneisiin, joiden kaappaus voi aiheuttaa vakavia ongelmia myös henkilöiden, rakennusten ja esineiden fyysiselle turvallisuudelle. Ongelman C-kielen kohdalla aiheuttaa erityisesti sen muistinkäsittely ominaisuudet, jotka sallivat ohjelmoijille monia eri vapauksia kirjoittaa ja hallita muistipaikkoja sekä pino- ja kekorakenteita. Hyökkääjä voi esimerkiksi yrittää saada pino-osoittimet haltuunsa ylikirjoittamalla muistipaikat jollain keksityllä paluuosoitteella. Tämän jälkeen aliohjelman käsittely siirtyy jonnekin hyökkääjän tahtomaan muistipaikkaan ja sitten alkaa tapahtua ei-toivottuja asioita, kuten tiedostojen siirtoa, oikeuksien hallinnan riistoa tai mitä tahansa hyökkääjä keksiikin. Hyökkääjä voi tyytyä myös vain kaatamaan ohjelman. Ylivuoto ongelmalle on tosin keksitty myös monta eri korjaustapaa ja ne voidaan jakaa kolmeen eri päätapaan, jotka ovat: virheiden välttäminen C-kieltä koodattaessa, koodausvirheiden löytäminen työkalujen avulla ja viimeisenä on käyttää turvallisia kieliä, kuten Javaa, Pythonia tai C#:a. Koko ohjelmointikielen vaihtaminen ei ole yleensä taloudellisesti järkevää ja sen takia joudutaan tyytymään usein kahteen ensimmäiseen korjaustapaan. Yksi työkalu ylivuotojen estämiseen, joka toisella videoluennolla esitetään, on kanarialinnun (eng. canary) käyttäminen ylivuotojen torjunnassa. Kanarialintu voi olla esimerkiksi jokin luku, jota tarkistetaan jostain pinon muistipaikasta. Sitten kun ollaan lopettamassa pinossa jokin aliohjelma ja ollaan palaamassa return-käskyllä muistiosoitteen osoittamaan seuraavaan kohtaan ohjelmassa, niin tarkastetaan ”kanarialintu” ensin, jos tämä luku on ylikirjoitettu jollain toisella merkkijonolla, niin tiedetään, että ohjelma on saastunut, eikä jatketa sen suorittamista. Nykyään myös C-kääntäjissä voi olla automaattinen kanarialinnun lisäysmahdollisuus, jolloin itse koodia ei tarvitse muuttaa miksikään, laittaa vaan toiminnon päälle. Menetelmän nimi tulee kaivoksissa käytetyistä kanarialinnuista, jotka valvoivat niissä ennen kaasuvuotoja. Menetelmä kuulostavat toimivalta ratkaisuilta myös pieniin ja langattomiin järjestelmiin, IoT-laitteisiin ja sensoriverkkoihin, koska ne eivät varaa niin paljon muistia ja kuluta siten tarpeettomasti energiaa. Toinen tapa ylivuotojen estämiseen on käyttää rajojen tarkastusta, missä puskurin ja tallennettavan tiedon kokoa valvotaan ja kirjoitus estetään, jos koko ei täsmää. If-lauseiden lisääminen voi kuitenkin tehdä koodista hitaan ja C-kielen käyttäminen ei ole enää niin perusteltua. Yksi tapa rajojen tarkastukseen on käyttää sähköaita-menetelmään, jossa jokaisen allokoidun muistiosoitteen viereen lisätään turvasivu, joka hälyttää, jos siihen kajotaan. Menetelmä aiheuttaa ohjelman välittömän kaatumisen, eikä muistiosoitteen korruptoidu pikkuhiljaa, niin kuin toisissa menetelmissä. Toimenpide kuluttaa valtavasti muistia, mutta on tehokas, siksi kokonaisen muistisivun lisääminen ei yleensä tule kysymykseen ja menetelmä on melko harvinainen. Toinen tapa rajojen tarkastukseen on käyttää ”lihavia osoittimia”. Menetelmässä osoittimeen lisätään raja-arvot. Nyt osoitin koostuu muistiosoitteen lisäksi muistiosoitteessa asuvan olion raja-arvoista. Tässä menetelmässä kääntäjä täytyy muokata käyttämään lihavia osoittimia ja kääntää ohjelmat uudelleen. Kääntäjä muodostaa koodin, joka keskeyttää ohjelman, jos osoitin on rajojen ulkopuolella. Lihavien osoittimien käyttö voi olla kallista, koska kaikki osoittimet on käytävä läpi. Toinen ongelma on se, että lihavat osoittimet eivät ole yhteensopivia kaikkien ohjelmien kanssa. 
## Luento 3
Kolmannen videoluennon aihe on ”Puskurin ylivuoto hyökkäysten arviointi”, joka jatkaa edellisellä luennolla aloitettua aihetta: rajojen tarkastus tavoista.  Kolmas tapa rajojen tarkastukseen on käyttää BBC-menetelmää (eng. Baggy Bounds Check). Menetelmän perusidea on tallentaa jokaisesta allokoidun objektin koko. Tämä voidaan tehdä esimerkiksi tallentamalla arvo, joka saadaan malloc()-funktiolla: ( char*p = malloc(mem_size);). Staattisille muuttujille arvot määrittelee kääntäjä -> (char p[256];). Jokaisesta osoittimelle tehdään kaksi operaatiota: otetaan talteen osoittimen aritmeettinen arvo -> (char *p = p + 256;). Haetaan ja otetaan talteen arvo, johon osoitin osoittaa-> (char ch = *q;).  Mihin aritmeettista arvoa sitten tarvitaan, eikö osoittimen tähtiarvo sitten riitä yksin? Aritmeettista arvoa tarvitaan, koska sen avulla voidaan seurata osoittimien alkuperää ja määritellä siten mitkä arvot ovat sallituissa rajoissa. Mutta mihin tähtiarvoa sitten tarvitaan, eikö osoittimen aritmeettinen arvo sitten riitä yksin? Joskus invalidi osoitin osoittaa yhden hypyn päähän jonosta, eikä se ole ohjelman kannalta virhe, koska sitä voidaan käyttää silmukan lopetuksessa hyväksi. Tämä menetelmä kuulostaa ihan toimivalta, eikä kuluta muistia niin paljon kuin toiset rajojen tarkastus menetelmät. Edellisessä luennossa esitettyjen kahden tavan lisäksi, kolmas tapa ylivuotojen estämiseen on estää koodin suorittaminen pinosta. Tämän mahdollistaa muistin suoritussuojaus (lyh. NX), jonka jälkeen hyökkääjä ei voi ajaa koodia pinosta. Muistien suoritussuojaus on uudempi ominaisuus, kuin luku- ja kirjoitussuojaus, joita on voitu tehdä jo pidempää. Jotkut järjestelmät jopa vaativat, että muisti on joko kirjoitettavaa tai suoritettavaa, mutta ei molempia. Menetelmän etuja on se, että se ei vaadi sovellukseen muutoksia. Toinen hyvä puoli on se, että rauta valvoo asiaa koko ajan toisin kuin käyttöjärjestelmä.  Neljäs tapa ylivuotojen estämiseen on käyttää osoiteavaruuden satunnaistamista (ASLR), tällöin pino aloitetaan satunnaisesta paikasta.  Osoiteavaruuden satunnaistamisessa pino siirretään satunnaiseen paikkaan, jolloin hyökkääjän on vaikeampi määritellä nykyisen kehyksen paluuosoitteen sijainti ja siten määrätä puskurin sijainti shell-koodissa. Hyökkääjä voi myös käyttää gdb:tä ja selvittää, missä muistiosoitteissa kiinnostavat kohteet sijaitsevat, mutta monta kertaa hyökkäyksissä käytetään kovakoodattuja muistiosoitteita shell-koodissa, joten osoiteavaruuden satunnaistaminen vaikeuttaa usein hyökkääjän työtä arvata kelvolliset kohteet.  Onkin hyvä satunnaistaa koko osoiteavaruus: pino, keko ja DLL-tiedostojen sijainti, koska koodi on usein uudelleen sijoitettavissa ja dynaaminen lataaja voi valita satunnaisen paikan jokaiselle kirjastolle. Silti hyökkääjä voi joskus arvata tai selvittää satunnaisuuden, etenkin 32-bitin järjestelmissä, joissa 232 virtuaalinen muistiavaruus on jaettu 4 kilotavun (212) sivuihin, joten 12 bittiä ei voi satunnaistaa ylittämättä sivun rajoja. Hyökkääjä voi käyttää myös puskurin ylivuotoa ja yrittää korvata palautusosoitteen usleep(16) käskyllä, ja sen jälkeen odottaa 16 sekuntia ja seurata kaatuuko järjestelmä. Jos järjestelmä kaatuu, niin serveri luo uuden prosessin samalla ASLR-offsetillä, jonka jälkeen hyökkääjä voi vaihtaa taas omia parametrejaan. Osoiteavaruuden satunnaistaminen onkin tämän vuoksi käytännöllisempää 64-bittisissä järjestelmissä, joissa voidaan käyttää suurempia satunnaislukuja. Puskurin ylivuotojen suojaamiseen käytetään yleisesti kanarialintua (Canary), jota käytetään GNU Compiler Collectionissa ja Microsoft Visual Studiossa oletuksena. Linuxissa ja Windowsissa käytetään taas oletuksena   osoiteavaruuden satunnaistamisessa (ASLR) ja muistin suoritussuojausta (NX). Rajojen tarkastukset eivät ole yhtä yleisiä, koska järjestelmien suorituskyky laskee yleensä, kun koodin määrä lisääntyy. Toinen syy on se, että ohjelmat joudutaan uudelleen ohjelmoimaan tarkoitusta varten. Kolmas syy on väärät hälytykset. Usein on parempi hyväksyä pikku puutteet ja ei yhtään väärää hälytystä, kuin toisin päin. Tämä on totta, koska mitä tietoturvatuotteiden: palomuurien ja virustentorjuntaohjelmien kanssa yleensä käy? Ne laskevat tietokoneen suorituskykyä usein liian alas ja sitten ne poistetaan käytöstä kokonaan. Tätä tapahtuu etenkin vanhoissa tietokoneissa, kun niihin ladataan uudet tietoturvaohjelmat.   

## Luento 4
Neljännellä videoluennon teemana oli eräs keskeisimmistä tietoturvaan liittyvistä menetelmistä, joka on oikeuksien hallinta. Sillä pyritään estämään tiettyjen käyttäjä- tai tehtävärooliryhmien avoin pääsy kaikkiin ohjelmiston osiin. Tällöin hyökkääjät eivät voi, esimerkiksi C-kielellä koodatussa ohjelmistossa, rikkoa koko ohjelmistoa puskurin ylivuodon avustukselle. Käyttöoikeuksien hallinta on myös tehokas tapa estää hyökkääjää tuhoamasta, varastamasta tai muuntamasta tiedostoja kaikissa ohjelmiston osissa, vaan hän joutuu murtautumaan, joka osalle erikseen. Tämä siis ilmiselvästi ainakin vaikeuttaa hyökkääjän työtä merkittävästi. Ohjelmiston yhden osion heikkous ei siis kaada koko ohjelmistoa. Tietoturvamenetelmänä oikeuksien rajaamien on yleinen ja sitä voidaan käyttää virtuaalikoneilla, Unix sukuisissa käyttöjärjestelmissä, SSH:lla, Chrome-selaimessa ja web-palvelimilla. Oikeuksien hallinnalla voidaan hallita prosessin järjestelmäkutsuja. Tämä tarkoittaa käytännössä sitä, että järjestelmäkutsujen käyttö rajataan pois tietyiltä henkilöiltä, tietyissä tapauksissa. Tällaisia tapauksia voivat olla esimerkiksi objekteihin, kuten tiedostoihin, kansioihin, tietoliikenne rajapintoihin, prosesseihin, muistikomponentteihin, filedeskriptoreihin ja tietokoneen lisälaitteisiin kohdistuvat käyttötapaukset. Tiedostojen osalta tällaisia käyttötapauksia ovat: kirjoitus-, luku- ja suoritusoikeudet. Hakemistojen osalta ne ovat taas luomis-, nimeämis-, poistamis- ja muuttamisoikeudet. Kun uusi tiedosto tai hakemisto luodaan, käyttöjärjestelmä myöntää luvat sen käyttämiseen, sen luomalle käyttäjälle (user), ryhmälle (gruop) ja muille käyttäjille (others). Id-komennolla voi katsoa käyttäjän ID (UID), ryhmän ID (GID) ja kaikkien niiden ryhmien nimet, joihin kuulut. Jokaisella tiedostolla ja hakemistolla on luku-, kirjoitus- ja suoritusoikeudet erikseen eri käyttäjäryhmille: käyttäjä, ryhmä ja muut. Ne esitetään tyypillisesti kolmella oktaaliluvulla, jotka tarkoittavat eri käyttäjäryhmiä: käyttäjä, ryhmä ja muut. Oktaaliluvut toimivat hyvin, koska jokainen numero on 3 bittinen. Bitit tarkoittavat luku-, kirjoitus- ja suoritussoikeuksia. Esimerkiksi oktaaliluku 754 on bitteinä 111101100, ensimmäiset 3 bittiä (111) tarkoittavat, että käyttäjällä on luku-, kirjoitus- ja suoritusoikeudet, seuraavat 3 bittiä (101) tarkoittavat, että ryhmällä on luku- ja suoritusoikeudet ja viimeiset 3 bittiä (100) tarkoittavat, että muilla on vain lukuoikeudet. Näitä käyttöoikeuksia voi muuttaa vain objektin omistaja. Tämä tietoturvamenetelmä on vanha, mutta erittäin käyttökelpoinen vielä tänäkin päivänä. Filedeskriptori on abstrakti indikaattori pääsyoikeudesta johonkin tiedostoon sisälle, kun prosessi on avannut tiedoston luvallisesti, syntyy myös filedeskriptorin, ja sen avulla voi jatkaa tiedoston käyttämistä vapaasti. Prosessit voivat myös välittää filedeskriptoreita toisille ohjelmille UNIX domain soketin kautta. Tällainen elossa oleva välitettävä filedeskriptori kuulostaa todella merkittävältä tietoturvariskiltä, koska voiko taitava hyökkääjä pitää tällaista elossa pitkään ja levittää niitä haluamiinsa kohteisiin? Prosesseille voidaan tehdä seuraavia seuraavanlaisia toimenpiteitä, kuten esimerkiksi: debuggaus, signaalin lähettäminen, exit-statuksen odottaminen ja exit-statuksen saaminen. Debuggaukseen ja signaalin lähettämiseen tarvitaan sama käyttäjätunnus, kun taas exit-statuksen odottaminen ja exit-statuksen saaminen edellyttää, että pitää olla prosessin vanhempi. Muistien osalta oikeuksien hallinnassa käytetään rajana prosessia, toinen prosessi ei voi yleisesti nimetä muistipaikkoja toiseen prosessiin. Poikkeuksina ovat debuggaus mekanismit ja muistiinkuvatut tiedostot. Tämäkin on tietoturvan kannalta merkityksellistä, koska hyökkäyksien tekeminen voisi olla helpompaa, jos voisi sotkea toisen ohjelman muistipaikat. En tiedä olisiko tällainen hyökkäys mahdollista? Verkkojen osalta operaatiot ovat: portin avaaminen, osoitteeseen yhdistäminen, luku ja kirjoitus yhteys ja ”raakojen” pakettien lähetys ja vastaan ottaminen. Oikeuksien hallinnalle on useita sääntöjä, esimerkiksi ainoastaan juuri eli käyttäjä-ID nro 0, voi avata portteja joiden järjestysluku on alle 1024. Tällä saavutetaan se, että satunnainen käyttäjä ei voi ajaa web-serveriä, jonka portti on 80. Ainoastaan UID 0 saa lähettää ”raakoja” paketteja.  Kaikki prosessit saavat taas luoda yhteyden, mihin tahansa prosessiin.  Käyttöoikeuksien hallinnalla saavutetut hyödyt tietoturvan parantamisessa ovat kiistattomat. Tällaisten ominaisuuksien puuttuminen esimerkiksi web-palvelimilta olisi aika vaikeasti korvattavissa millään muulla tavalla. 
## Luento 6
Kuudennen videoluennon aihe on ohjelmien valtakirjat (eng. capabilities). Videoluento alkaa kuvaavalla esimerkillä ”confused depute” -ongelmalla, jossa ohjelmalla on valtakirja ylikirjoittaa jokin tiedosto, vaikka itse henkilöllä ei kirjoitusoikeutta olisikaan.  Esimerkissä kääntäjällä käännetään tiedosto ja muodostuneella tiedostolla ylikirjoitetaan saman niminen jo olemassa oleva tiedosto. Esimerkin tietoturvaongelma on todella olemassa. Kuudennella videoluennolla esitettiin myös sandboxing-suojaustekniikka, jolla käytettävät ohjelmat eristetään muusta järjestelmästä omaan hiekkalaatikkoonsa, jolloin ne eivät pääse käsiksi muihin tiedostoihin tai tekemään pysyviä muutoksia eri muisteihin. Sandbox-suojaustekniikka tuo tietokoneeseen ylimääräisen turvakerroksen tai palomuurin, tällöin ohjelman valtakirjat ja sitä mukaa oikeudet vähenevät. Sandbox-suojaustekniikkaa voidaan käyttää esimerkiksi web-palvelimissa (eng. lyh. OKWS) tai ohjelmissa, jotka käsittelevät verkkoyhteyksiä, etenkin niiden sisääntuloja. Sandbox-suojaustekniikkaa on myös hyvä käyttää ohjelmissa, joilla manipuloidaan dataa monimutkaisesti, kuten esimerkiksi seuraavilla ohjelmilla: gzip, Chromium, eri media koodekit ja selaimien lisäosat. Laitetaan monimutkainen ja usein epäilyttävä osa ”hiekkalaatikkoon”. Sandbox-suojaustekniikalla voi käyttää mitä tahansa ohjelmaa, jonka luotettavuus herättää epäilyjä, että siihen on saatettu piilottaa jokin virus. Erityisesti tulee mieleen käyttää tekniikkaa maksuttomien ohjelmistojen kanssa, joissa piilee usein vaara, että ohjelmisto paljastuu troijalaiseksi. Yksi vaihtoehto on, että ohjelmoijat alkavat ohjelmoimaan sovelluksensa siten, että ne käyttävät suoraan sandbox-suojaustekniikkaa hyväksi. Tämä toimii joissakin tapauksissa, kuten Javascript:llä, Java:lla ja Native Client:in kanssa. Tämän vuoksi olisikin syytä standardoida ympäristö Sandbox-koodin ajamiselle. Menetelmä kuulostaa toimivalta, olisiko siitä haittaa sovellukselle, jos jotkut sen osat toimisivat taustalla hiekkalaatikossa? Ei pitäisi olla. Sandbox-suojaustekniikan käyttäminen voi olla myös hyväksi, kun käytetään ohjelmia, joissa voi olla riski oikeuksien hallinnan kanssa. Tarkemmin sanottuna, että jos on olemassa riski, että hyökkääjä saa oikeuksien hallinnan sekaisin tai sitten tämä tapahtuu vahingossa. Voisiko sandbox-suojaustekniikkaa siis käyttää vaikkapa pelkästään tiedoston avaamiseen? Mitkä ovat siis sandbox-suojaustekniikan suojamekanismit ja onko niillä etuja ja rajoituksia? Käyttöjärjestelmä tarjoaa tyypillisesti joitakin primitiivisiä suojamekanismeja, kuten käyttäjä- ja ryhmätunnukset. mutta todelliset OS-tason sandbox-suojamekanismit luodaan prosesseihin. Ne toimivat hyvin koko prosessissa, jotka voidaan eristään yhdeksi kokonaisuudeksi.  Sovellus joudutaan kuitenkin usein ohjelmoimaan uudestaan, jotta prosessit saadaan eristettyä.  Myös muilla tekniikoilla voidaan luoda hienojakoista eristystä, näitä ovat esimerkiksi kooditason eristys Javascriptissa ja binäärinen instrumentaatio Native Client:issa. Usein näitä hienojakoisia ja OS-tason sandbox-suojatekniikoita käytetään yhdessä. Yksi Sandbox-tekniikka on kaiken virtualisointi, kun ajaa kaiken epäluotettavan koodin virtuaalisessa ympäristössä, niin pahaa ei pääse käymään. Tällä periaatteella on tehty monia ohjelmia, kuten x86 qemu, FreeBSD jails ja Linux LXC. Virtuaalikoneen käyttö estää kaiken lähes kaiken yhteydenpidon muun järjestelmän kanssa ja se on myös yhdistettävissä muiden eristystekniikoiden kanssa. Haittapuolena siinä on, että prosesseja, putkia tai tiedostoja ei pystytä jakamaan. Toinen negatiivinen asia on, että tekniikka on melko raskaskäyttöinen ja se aiheuttaa CPU:lle ja muisteihin viiveitä. Toinen sandbox-tekniikka on DAC (eng. Discretionary Access Control) eli harkinnanvarainen pääsyn hallinta. DAC-tekniikan ideana on luoda jokaiselle objektille, kuten tiedostoille ja hakemistoille, omat pääsyn hallinta listat, joiden avulla niihin pääsyä rajataan. Jokainen ohjelma käyttää jotakin oikeuksia, kuten UID, GID ja SetupID, kun ohjelma yrittää avata jonkin tiedoston, niin tätä yksittäistä pääsyä valvotaan erikseen, jos ohjelma kokee sen tarpeelliseksi. Kolmas sandbox-tekniikka on MAC (eng. Mandatory Access Control) eli pakollinen pääsyn hallinta eroaa DAC-tekniikasta siten, että sovellukset eivät voi itse päättää sitä, että valvotaanko yksittäistä pääsyä johonkin tiedostoon erikseen. Monet systeemit kuitenkin käyttävät, sekä MAC-tekniikkaa, että DAC-tekniikkaa.
## Luento 17
17. videoluennon aihe oli käyttäjien autentikointi. Aiheen ydinhaasteena on se, miten ihmiset todistavat oman henkilöllisyytensä ohjelmalle. Salasanat ovat olleet tietoturvan tärkein menetelmä tietokoneiden synnystä asti ja ovat sitä vielä tänään ja huomennakin. Onko salasanojen korvaajaksi olemassa yhtään todellista tekniikkaa. Salasanat ovat yleisesti ottaen surkeita, niissä on alhainen entropia eli hyökkääjän on helppo arvata ne, ja kun salasanan unohtaa pitää vastata turvakysymyksiin, jotta ne saadaan uusittua. Turvakysymyksien entropia on myös alhainen. Näiden kahden heikkouden lisäksi, ovat vielä käyttäjät itse. Tietoturvaa ei lisää myöskään se tieto, että käyttäjät laittavat samoja salasanoja useille eri sivustoille. Videoluennon luennoija jopa sanoo, että ”Salasanojen jatkuva dominointi, muihin metodeihin verrattuna, on suuri häpeä koko tiedeyhteisölle.” Mutta mikä salasana sitten todella on? Se on salaisuus, jonka tietävät käyttäjä ja palvelin. Naivissa implementaatiossa palvelimella on taulukko, joka yhdistää käyttäjänimet ja salasanan merkkijono muodossa. Tämän ongelmana on se, että jos hyökkääjä pääsee murtautumaan palvelimelle, hän saa kaikki käyttäjätunnus salasana parit mukaansa. Tämä todellakin kuulostaa riskialttiille menetelmälle. Todellisuudessa tässä käytetäänkin apuna hajautusta, jolloin palvelimelle tallennetaan käyttäjänimi ja pitkä hajautettu merkkijono, joten hyökkääjä ei voi saada suoraan käyttäjätunnus salasana pareja selville. Etuna on vielä, että hajautusfunktio ovat myös hankalia kääntää, joten edes raakaan laskentatehoon perustuvat salasanojen murtamismenetelmät eivät toimi. Ongelmana on se, että hyökkääjän ei tarvitse käyttää tehottomia raakaan voimaan perustuvia menetelmiä kaikkiin mahdollisiin salasanoihin, vaan todellisuudessa käytettyjen salasanojen joukko on todella pieni. Jonkin tutkimuksen mukaan 5000 salasanaa peittää 20% käyttäjistä. Palvelin voi käyttää myös laskennallisesti raskasta derivaatio funktiota salasanojen hajautuksessa. Tällaisia funktioita ovat esimerkiksi BCrypt ja PBKDF2. Tämänkin murtamiseen hyökkääjillä on oma konsti, nimittäin ”sateenkaaritaulukot”. Nämä sateenkaaritaulukot ovat salasana-hash taulukoita. Ne antavat hyökkääjälle mahdollisuuden selvittää hajautukset jälkikäteen, tämä laskenta on tosin melko hidasta. Palvelimen kannalta parempi ratkaisu on taas käyttää salasanojen suolausta, joka tarkoittaa sitä, että hajautuksessa käytetään salasanan lisäksi satunnaislukua. Satunnaisluku tallennetaan palvelimelle, joten hyökkääjä saa senkin selville, jos haluaa? Hyökkääjä ei voi kuitenkaan käyttää vain yhtä sateenkaaritaulua hajautus tulosten selvittämiseen, koska samalla salasanalla ja eri suolalla on eri hajautusarvo.  On parasta valita pitkä satunnainen suola ja vaihtaa suolaa aina, kun salasana vaihdetaan uudeksi. On myös muistettava, että salasanaa ei saa lähettää palvelimelle suojaamattomana. Raakaan voimaan perustuvilta salasanojen murtamismenetelmiltä voidaan taas suojautua menetelmällä, joka estää ”vasaroinnin”. Tämä tapahtuu estämällä salasanojen loputtomat uudelleen yritykset ja asettamalla viive, minkä jälkeen salasanaa voi kokeilla uudelleen. On tärkeää säädellä arvaustaajuutta, koska salasanojen entropia on niin heikko. Monilla sivuilla on käytössä sääntöjä, joiden mukaan salasanat tulee kirjoittaa, niissä voidaan määrätä esimerkiksi salasanan pituus, merkkejä jne. Todellisuudessa hyökkääjä voi kuitenkin myös soveltaa sääntöjä omissa sateenkaaritaulukoissaan ja säännöt eivät muutu paremmaksi entropiaksi. Mitä muuta voidaan käyttää salasanojen tilalla? Biometrisia tunnisteita, kuten sormenjälkeä, iiriksen skannausta ja äänen tunnistusta, mutta niillä on harvoin parempi entropia, kuin salasanoilla. Joskus autentikoinnissa onkin hyvä käyttää eri äänen tunnistusmenetelmien yhdistelmiä, jolloin entropia on huomattavasti parempi. Salasanojen palauttiminen on taas erittäin tärkeää, mutta se unohdetaan usein. Ihmiset fokusoivat yleensä salasanan entropiaa, vaikka taustakysymysten entropia on vielä huonompi. Ne ovat yleensä helposti arvattavissa.
## Luento 10
## Luento 8
## Luento 9
## Luento 18
## Luento 7
## Luento 21
